The goal here is to find a solution for the problem of potentially touching mutable states inside of futures answering
in AKKA actors.

The main solution is in the `MessageBasedExecutor` class. It is used inside of `ConcurrencyTestActor` to ensure that
anything made using a `Future` inside of the actor will be executed in a thread safe fashion, as it would be for a
standard message receiving.

The way this demo works:
- `Application` sends a bunch of messages to `ConcurrencyTestActor`.
- `ConcurrencyTestActor` forwards them to `ServiceActor` using the ask pattern.
- `ServiceActor` starts a `Future` on the normal context (the thread pool) and pipes the future to the sender (`ConcurrencyTestActor`).
- `ConcurrencyTestActor` maps a couple of the time and has a `onComplete`. All those are executed using the `MessageBasedExecutor`
   which is sending the `Runnable` generated by the `Future` high-order functions as a message to "itself" (`ConcurrencyTestActor`).
- The logging should then show no `ERROR` since there is always only ONE thing happening at the same time within this actor.

To make the test "fail", comment this line:

```
implicit protected val executor = MessageBasedExecutor(self, context.dispatcher)
```

and uncomment this line:

```
// import context._ // <-- DO NOT DO THIS, otherwise the implicit 'executor' declared next will be bypassed :'(
```

That will make the actor use the context's `dispatcher`, making all future based calls be executed on the thread pool,
in parallel.
